{"version":3,"sources":["../../src/lib/config.ts","../../src/lib/common-form-control.directive.ts","../../src/lib/common-form.directive.ts","../../src/lib/common-forms.module.ts","../../src/lib/sins.directive.ts","../../src/lib/sin.directive.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/lib/form-with-sins.directive.ts","../../src/lib/sin.module.ts"],"names":["COMMON_FORM_CONFIG","InjectionToken","COMMON_FORM_FULL_CONFIG","COMMON_FORM_CONTROL","SIN_CONFIG","SIN_FULL_CONFIG","providerFactory","klass","provide","useExisting","forwardRef","DefaultCommonFormControlDirective","renderer","elRef","this","Object","defineProperty","prototype","name","setName","_name","setAttribute","nativeElement","getName","focus","Directive","args","selector","providers","Renderer2","ElementRef","Input","uniqueId","CommonFormControlDirective","ngControl","commonFormControl","ngOnInit","x","newName","toString","console","warn","path","join","NgControl","decorators","type","Self","Optional","Inject","CommonFormDirective","container","config","submit$","rx.Subject","isLoading","EventEmitter","commonFormSubmit","asObservable","request","_this","propagateErrors","transform","isValidationError","transformError","ngSubmit","pipe","rxop.tap","event","preventDefault","preSubmit","rxop.map","control","rxop.filter","form","valid","abstractControls","controls","map","ctrl","forEach","markAsDirty","markAsTouched","firstInvalidControl","find","invalid","value","emit","rxop.exhaustMap","rxop.catchError","httpErrorResponse","flatErrors","controlsWithErrors_1","setErrors","indexOf","rx.throwError","rx.EMPTY","rxop.finalize","err","caught","error","subscribe","response","rx.of","errors","keys","get","controlNames","controlName","markControlsAsDirtyAndTouchedByPath","serverError","formValue","status","commonConfigFactory","partialCommonFormConfig","assign","FormGroupDirective","Output","ContentChildren","descendants","DIRECTIVES","CommonFormsModule","forRoot","ngModule","useValue","useFactory","deps","NgModule","imports","CommonModule","declarations","exports","SinsDirective","nameOrControl","ControlContainer","SinDirective","templateRef","viewContainerRef","sinsDirective","controlContainer","visible$","rx.BehaviorSubject","initialized","_control","initialize","_controlWithErrors","Error","isDevMode","ngDoCheck","evaluate","when","whenControl","whenObj","disabled","dirty","enabled","pending","pristine","touched","untouched","hasError","controlWithErrors","shouldDisplay","create","destroy","embeddedViewRef","next","createEmbeddedView","$implicit","TemplateRef","ViewContainerRef","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","done","push","findAdded","_a","_b","olders","filter","newer","FormWithSinsDirective","elementRef","destroy$","classNameForInvalidControl","markValidityFor","addClass","index","formControlNames","toArray","findIndex","formControlName","formControlElRefs","removeClass","markValidityForAll","markAllAsValid","ngAfterContentInit","sinDirectives","formControls","rx.zip","changes","rxop.startWith","visibleSins$","list","rxop.switchMap","sins","rx.combineLatest","sin","rxop.withLatestFrom","fc","s","getValue","_","rxop.pairwise","oldControls","newControls","added","removed","findRemoved","ngOnDestroy","FormControlName","read","defaultConfig","factory","SinModule","ReactiveFormsModule"],"mappings":"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","sourcesContent":["import {InjectionToken} from '@angular/core'\nimport {CommonFormConfig, SinModuleConfig} from './interfaces'\n\nexport const COMMON_FORM_CONFIG =\n  new InjectionToken<Partial<CommonFormConfig>>('COMMON_FORM_CONFIG')\n\nexport const COMMON_FORM_FULL_CONFIG =\n  new InjectionToken<CommonFormConfig>('COMMON_FORM_FULL_CONFIG')\n\nexport const COMMON_FORM_CONTROL =\n  new InjectionToken<any>('COMMON_FORM_CONTROL')\n\nexport const SIN_CONFIG =\n  new InjectionToken<Partial<SinModuleConfig>>('SIN_CONFIG')\n\nexport const SIN_FULL_CONFIG\n  = new InjectionToken<SinModuleConfig>('SIN_FULL_CONFIG')\n","import {COMMON_FORM_CONTROL} from './config'\nimport {Directive, ElementRef, forwardRef, Inject, Input, OnInit, Optional, Renderer2, Self} from '@angular/core'\nimport {CommonFormControl} from './interfaces'\nimport {NgControl} from '@angular/forms'\n\nfunction isEmpty (x: string): boolean {\n  return x == null || x == ''\n}\n\nexport function providerFactory (klass: any) {\n  return {\n    provide: COMMON_FORM_CONTROL,\n    useExisting: forwardRef(() => klass),\n  }\n}\n\n@Directive({\n  selector: 'input:not([notCommonControl]),select:not([notCommonControl]),textarea:not([notCommonControl])',\n  providers: [providerFactory(DefaultCommonFormControlDirective)],\n})\nexport class DefaultCommonFormControlDirective implements CommonFormControl {\n\n  private _name: string\n\n  @Input()\n  public set name (name: string) {\n    this.setName(name)\n  }\n\n  constructor (private renderer: Renderer2, private elRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) {\n  }\n\n  public setName (name: string): void {\n    this._name = name\n    this.renderer.setAttribute(this.elRef.nativeElement, 'name', name)\n  }\n\n  public getName (): string {\n    return this._name\n  }\n\n  public focus (): void {\n    this.elRef.nativeElement.focus()\n  }\n\n}\n\nlet uniqueId = 0\n\n@Directive({\n  selector: '[formControlName]:not([notCommonControl]),[formControl]:not([notCommonControl])',\n})\nexport class CommonFormControlDirective implements OnInit {\n\n  constructor (@Self() public ngControl: NgControl,\n               @Self() @Optional() @Inject(COMMON_FORM_CONTROL) public commonFormControl: CommonFormControl) {\n  }\n\n  public ngOnInit (): void {\n    if (!this.commonFormControl) {\n      console.warn(\n        `A control inside a Common Form does not provide COMMON_FORM_CONTROL token. ` +\n        `It will be ignored. If you do not wish Common Form to be aware of this control, add ` +\n        `[notCommonControl] selector. Path to control: \"${this.ngControl.path.join('.')}\".`,\n      )\n      return\n    }\n\n    if (isEmpty(this.commonFormControl.getName())) {\n      const newName = this.ngControl.name.toString() || `common-form-control-name-${++uniqueId}`\n      this.commonFormControl.setName(newName)\n    }\n  }\n\n}\n","import {AbstractControl, FormGroup, FormGroupDirective} from '@angular/forms'\nimport {ContentChildren, Directive, EventEmitter, Inject, Input, OnInit, Output, QueryList, Self} from '@angular/core'\nimport * as rx from 'rxjs'\nimport * as rxop from 'rxjs/operators'\nimport {\n  CommonFormConfig,\n  CommonFormIsValidationError,\n  CommonFormRequest,\n  CommonFormTransform,\n  CommonFormTransformError,\n  FlatServerErrors,\n} from './interfaces'\nimport {COMMON_FORM_FULL_CONFIG} from './config'\nimport {CommonFormControlDirective} from './common-form-control.directive'\nimport {HttpErrorResponse} from '@angular/common/http'\n\nfunction markControlsAsDirtyAndTouched (controls: AbstractControl[]) {\n  controls.forEach(control => {\n    control.markAsDirty()\n    control.markAsTouched()\n  })\n}\n\nexport function markControlsAsDirtyAndTouchedByPath (form: FormGroup, controlNames: string[]) {\n  controlNames.forEach(controlName => {\n    const control = form.get(controlName)\n    if (control != null) {\n      control.markAsTouched()\n      control.markAsDirty()\n    } else {\n      console.error(\n        `Attempted to set control with name ${controlName} as dirty and touched, ` +\n        `but it was not found.`,\n      )\n    }\n  })\n}\n\n@Directive({\n  selector: '[commonForm]',\n})\nexport class CommonFormDirective implements OnInit, CommonFormConfig {\n\n  private submit$ = new rx.Subject<any>()\n\n  @Output() public isLoading = new EventEmitter<boolean>()\n\n  public get isLoading$ (): rx.Observable<boolean> {\n    return this.isLoading.asObservable()\n  }\n\n  @Output() public commonFormSubmit = new EventEmitter<rx.Observable<any>>()\n\n  /**\n   * Set to true if you want to propagate errors to the consumer component.\n   */\n  @Input() public propagateErrors: boolean\n\n  /**\n   * Right after the form's submit event and before ngx-common-forms does anything,\n   * this function will be run if given.\n   */\n  @Input() public preSubmit?: () => void\n\n  /**\n   * Set this input to override the provided transform function.\n   */\n  @Input() public transform: CommonFormTransform\n\n  /**\n   * A predicate to determine if the error is supposed to be treated as a validation\n   * error from the server response.\n   */\n  @Input() public isValidationError: CommonFormIsValidationError\n\n  /**\n   * Set this input to override the provided transform error function.\n   */\n  @Input() public transformError: CommonFormTransformError\n\n  /**\n   * A function returning an observable, probably doing a request to the network.\n   * Does nothing by default and can be omitted. This is useful for less typical\n   * use-cases when the request should be sent from the consumer side for finer\n   * control.\n   */\n  @Input() public request: CommonFormRequest\n\n  /**\n   * An alias for \"request\", purposely named the same as the directive so it can\n   * be used in a less verbose fashion..\n   */\n  @Input()\n  public set commonForm (request: (x: any) => rx.Observable<any>) {\n    this.request = request\n  }\n\n  /**\n   * @internal\n   *\n   * Used internally to kep track of form controls within the common form.\n   */\n  @ContentChildren(CommonFormControlDirective, {descendants: true})\n  public controls: QueryList<CommonFormControlDirective>\n\n  constructor (@Self() private container: FormGroupDirective,\n               @Inject(COMMON_FORM_FULL_CONFIG) private config: CommonFormConfig) {\n  }\n\n  public ngOnInit (): void {\n    if (this.propagateErrors == null) {\n      this.propagateErrors = this.config.propagateErrors\n    }\n\n    if (this.transform == null) {\n      this.transform = this.config.transform\n    }\n\n    if (this.isValidationError == null) {\n      this.isValidationError = this.config.isValidationError\n    }\n\n    if (this.transformError == null) {\n      this.transformError = this.config.transformError\n    }\n\n    if (this.request == null) {\n      this.request = this.config.request\n    }\n\n    this.container.ngSubmit.pipe(\n      rxop.tap((event: Event) => {\n        event.preventDefault()\n        if (this.preSubmit != null) {\n          this.preSubmit()\n        }\n      }),\n      rxop.map(() => this.container.control),\n      rxop.filter(form => {\n        if (form.valid) {\n          return true\n        } else {\n          const abstractControls = this.controls.map(ctrl => ctrl.ngControl.control)\n          markControlsAsDirtyAndTouched(abstractControls)\n          const firstInvalidControl = this.controls.find(ctrl => ctrl.ngControl.invalid)\n          if (firstInvalidControl != null) {\n            firstInvalidControl.commonFormControl.focus()\n          }\n          return false\n        }\n      }),\n      rxop.map(form => this.transform(form.value)),\n      rxop.tap(() => this.isLoading.emit(true)),\n      rxop.exhaustMap(value => this.request(value).pipe(\n        rxop.catchError((httpErrorResponse: HttpErrorResponse) => {\n          if (this.isValidationError(httpErrorResponse)) {\n            const flatErrors = this.transformError(httpErrorResponse)\n            const controlsWithErrors = this.setErrors(flatErrors)\n            const firstInvalidControl = this.controls\n              .find(ctrl => controlsWithErrors.indexOf(ctrl.ngControl.control) > -1)\n            if (firstInvalidControl != null) {\n              firstInvalidControl.commonFormControl.focus()\n            }\n          }\n          if (this.propagateErrors) {\n            this.commonFormSubmit.emit(rx.throwError(httpErrorResponse))\n          }\n          return rx.EMPTY\n        }),\n        rxop.finalize(() => this.isLoading.emit(false)),\n        ),\n      ),\n      rxop.finalize(() => this.isLoading.emit(false)),\n      rxop.catchError((err, caught) => {\n        console.error(`Error while handling form submission inside Common Form`, err)\n        return caught\n      }),\n    ).subscribe(response => {\n      this.commonFormSubmit.emit(rx.of(response))\n    })\n\n  }\n\n  private setErrors (errors: FlatServerErrors): AbstractControl[] {\n    const form = this.container.form as FormGroup\n\n    Object.keys(errors).forEach(path => {\n      const control = form.get(path)\n      if (control == null) {\n        console.error(\n          `API claims that a afield with path ${path} is invalid, ` +\n          `but no such field was found on the form.`,\n        )\n      } else {\n        markControlsAsDirtyAndTouchedByPath(form, [path])\n        form.get(path).setErrors({serverError: errors[path]})\n      }\n    })\n\n    return Object.keys(errors).map(path => form.get(path))\n  }\n\n}\n","import {ModuleWithProviders, NgModule} from '@angular/core'\nimport {HttpErrorResponse} from '@angular/common/http'\nimport * as rx from 'rxjs'\nimport {CommonModule} from '@angular/common'\nimport {CommonFormConfig, FlatServerErrors} from './interfaces'\nimport {COMMON_FORM_CONFIG, COMMON_FORM_FULL_CONFIG} from './config'\nimport {CommonFormDirective} from './common-form.directive'\nimport {DefaultCommonFormControlDirective, CommonFormControlDirective} from './common-form-control.directive'\n\n/**\n * A function which takes the form value object and returns\n * a \"transformed\" version. By default, it's an identity.\n */\nexport function transform (formValue: any): any {\n  return formValue\n}\n\n/**\n * Forms are usually submitted to the server, and there's a\n * loading spinner going on somewhere while waiting for the\n * response from the server to arrive. The response could\n * be a success, which is usually the simplest thing that\n * could happen in the app. However, in case of an error,\n * we need to show some validation messages in the fields\n * where the user needs to check his input. This is where\n * the problems begin, and this is what the library solves.\n * This function checks if the error returned from the\n * server is a validation error. I have a habit of marking\n * those with a status 422 (UNPROCESSABLE ENTITY), but in\n * case your code does something else, this is the\n * function you override in order to change how the lib\n * figures out that the response from the server contains\n * a validation error.\n */\nexport function isValidationError (response: HttpErrorResponse): boolean {\n  return response.status == 422\n}\n\n/**\n * The error returned from the server doesn't have to\n * match the \"flat server error\" format which the library\n * expects. See docs for `FlatServerErrors` for more about\n * the format, and override this function to specify your\n * own transformation.\n */\nexport function transformError (serverError: any): FlatServerErrors {\n  return serverError\n}\n\n/**\n * This one might seem a bit weird, but there's actually a\n * default function which transforms the form value into an\n * observable that's responsible for sending the request.\n * The default value is a mocked observable which just emits\n * what's given to it, but this is almost always overridden\n * per form, by giving it a function which performs an HTTP\n * request, returning the observable.\n */\nexport function request<T = any> (formValue: T): rx.Observable<T> {\n  return rx.of(formValue)\n}\n\nexport function commonConfigFactory (partialCommonFormConfig?: Partial<CommonFormConfig>) {\n  return Object.assign({\n    propagateErrors: false,\n    transform,\n    isValidationError,\n    transformError,\n    request,\n  }, (partialCommonFormConfig || {}))\n}\n\nexport const DIRECTIVES = [\n  CommonFormDirective,\n  CommonFormControlDirective,\n  DefaultCommonFormControlDirective,\n]\n\n@NgModule({\n  imports: [\n    CommonModule,\n  ],\n  declarations: DIRECTIVES,\n  exports: DIRECTIVES,\n})\nexport class CommonFormsModule {\n  public static forRoot (config?: Partial<CommonFormConfig>): ModuleWithProviders<CommonFormsModule> {\n    return {\n      ngModule: CommonFormsModule,\n      providers: [\n        {\n          provide: COMMON_FORM_CONFIG,\n          useValue: config,\n        },\n        {\n          provide: COMMON_FORM_FULL_CONFIG,\n          useFactory: commonConfigFactory,\n          deps: [COMMON_FORM_CONFIG],\n        },\n      ],\n    }\n  }\n}\n","import {Directive, Input, OnInit} from '@angular/core'\nimport {AbstractControl, ControlContainer} from '@angular/forms'\n\n@Directive({\n  selector: '[sins]',\n})\nexport class SinsDirective implements OnInit {\n\n  @Input('sins') public nameOrControl: string | AbstractControl\n\n  public control: AbstractControl\n\n  constructor (private container: ControlContainer) {\n  }\n\n  public ngOnInit (): void {\n    this.control = typeof this.nameOrControl == 'string'\n      ? this.container.control.get(this.nameOrControl)\n      : this.nameOrControl\n  }\n\n}\n","import {AbstractControl, ControlContainer} from '@angular/forms'\nimport {Directive, DoCheck, EmbeddedViewRef, Inject, Input, isDevMode, OnInit, Optional, TemplateRef, ViewContainerRef} from '@angular/core'\nimport {SinModuleConfig, WhenFunction, WhenObject} from './interfaces'\nimport * as rx from 'rxjs'\nimport {SIN_FULL_CONFIG} from './config'\nimport {SinsDirective} from './sins.directive'\n\nexport interface SinNotification {\n  type: 'add'\n  control: AbstractControl\n  error: any\n}\n\n@Directive({selector: '[sin]'})\nexport class SinDirective implements OnInit, DoCheck, SinModuleConfig {\n\n  public visible$ = new rx.BehaviorSubject<AbstractControl | null>(null)\n\n  private _control: AbstractControl\n  private _controlWithErrors: AbstractControl\n\n  @Input('sin') error: string\n\n  @Input('sinControl')\n  public set control (control: AbstractControl) {\n    this._control = control\n    this.initialize()\n  }\n\n  public get control (): AbstractControl {\n    return this._control\n  }\n\n  // A shorter way to provide a control by only specifying the name\n  @Input('sinName') public name: string\n\n  @Input('sinErrorFromControl')\n  public set controlWithErrors (control: AbstractControl) {\n    this._controlWithErrors = control\n  }\n\n  public get controlWithErrors (): AbstractControl {\n    return this._controlWithErrors || this.control\n  }\n\n  @Input('sinWhen') when: WhenFunction\n\n  private embeddedViewRef: EmbeddedViewRef<any>\n  private initialized = false\n\n  constructor (private templateRef: TemplateRef<any>,\n               private viewContainerRef: ViewContainerRef,\n               @Inject(SIN_FULL_CONFIG) private config: SinModuleConfig,\n               @Optional() private sinsDirective: SinsDirective,\n               @Optional() private controlContainer: ControlContainer) {\n  }\n\n  public ngOnInit (): void {\n    if (this.sinsDirective) {\n      // If we're inside a sins group, use the form control specified there\n      this.control = this.sinsDirective.control\n    } else {\n      if (this.name != null) {\n        // If nameOrControl is given instead of a control\n        if (this.controlContainer == null) {\n          // Name is useless if we're not inside a container such as FormGroup.\n          throw new Error(`You cannot register sinName \"${this.name}\" outside of a control ` +\n            `container. You can use the sinControl input to pass in the control directly.`)\n        } else {\n          // We grab the control with such nameOrControl\n          const control = this.controlContainer.control.get(this.name)\n          if (control == null) {\n            // There's no control with such nameOrControl, probably a typo.\n            throw new Error(`Cannot find control \"${name}\" to bind to sin.`)\n          } else {\n            // We use this control. It's important we trigger the setter here.\n            this.control = control\n          }\n        }\n      }\n    }\n\n    if (isDevMode() && this.control == null) {\n      // Control has not been specified directly (sinControl),\n      // cannot be determined by the given nameOrControl (sinName),\n      // and there is no enclosing sins.\n      throw new Error(`No control specified for sin.`)\n    }\n  }\n\n  public ngDoCheck (): void {\n    if (!this.initialized) {\n      return\n    }\n    this.evaluate()\n  }\n\n  private initialize () {\n    if (this.when == null) {\n      this.when = this.config.when\n    }\n\n    this.initialized = true\n  }\n\n  private evaluate () {\n    const whenControl = this.control\n    const whenObj: WhenObject = {\n      disabled: whenControl.disabled,\n      dirty: whenControl.dirty,\n      enabled: whenControl.enabled,\n      invalid: whenControl.invalid,\n      pending: whenControl.pending,\n      pristine: whenControl.pristine,\n      touched: whenControl.touched,\n      untouched: whenControl.untouched,\n      valid: whenControl.valid,\n    }\n\n    const hasError = this.controlWithErrors.hasError(this.error)\n    const shouldDisplay = this.when(whenObj)\n\n    if (hasError && shouldDisplay) {\n      this.create()\n    } else {\n      this.destroy()\n    }\n  }\n\n  private create () {\n    if (this.embeddedViewRef == null) {\n      this.visible$.next(this.control)\n      const error = this.controlWithErrors.errors[this.error]\n      this.embeddedViewRef = this.viewContainerRef\n        .createEmbeddedView(this.templateRef, {$implicit: error})\n    }\n  }\n\n  private destroy () {\n    if (this.embeddedViewRef != null) {\n      this.visible$.next(null)\n      this.embeddedViewRef.destroy()\n      this.embeddedViewRef = null\n    }\n  }\n\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {AfterContentInit, ContentChildren, Directive, ElementRef, OnDestroy, Optional, QueryList, Renderer2, Self} from '@angular/core'\nimport {SinDirective} from './sin.directive'\nimport {AbstractControl, ControlContainer, FormControlName, FormGroup} from '@angular/forms'\nimport * as rx from 'rxjs'\nimport * as rxop from 'rxjs/operators'\n\nexport type Pair<T> = [T, T]\n\nexport function findAdded<T> ([olders, newers]: Pair<T[]>): T[] {\n  return newers.filter(newer => olders.indexOf(newer) == -1)\n}\n\nexport function findRemoved<T> ([olders, newers]: Pair<T[]>): T[] {\n  return findAdded([newers, olders])\n}\n\n@Directive({selector: 'form'})\nexport class FormWithSinsDirective implements AfterContentInit, OnDestroy {\n\n  @ContentChildren(SinDirective, {descendants: true})\n  public sinDirectives: QueryList<SinDirective>\n\n  @ContentChildren(FormControlName, {descendants: true})\n  public formControlNames: QueryList<FormControlName>\n\n  @ContentChildren(FormControlName, {descendants: true, read: ElementRef})\n  public formControlElRefs: QueryList<ElementRef>\n\n  private formControls: rx.Observable<{ name: FormControlName, elRef: ElementRef }>\n\n  private destroy$ = new rx.Subject()\n\n  private classNameForInvalidControl = 'ngx-sin-invalid'\n\n  constructor (@Optional() @Self() private controlContainer: ControlContainer,\n               private renderer: Renderer2,\n               private elementRef: ElementRef) {\n  }\n\n  private markValidityFor (control: AbstractControl, addClass: boolean): void {\n    const index = this.formControlNames.toArray()\n      .findIndex(formControlName => {\n        return control == formControlName.control\n      })\n\n    let elRef: ElementRef\n\n    if (index == -1) {\n      const formGroup = this.controlContainer.control as FormGroup\n      if (formGroup == control) {\n        elRef = this.elementRef\n      } else {\n        // Could not find the FormControl in the view, do nothing\n        return\n      }\n    } else {\n      elRef = this.formControlElRefs.toArray()[index]\n    }\n\n    if (addClass) {\n      this.renderer.addClass(elRef.nativeElement, this.classNameForInvalidControl)\n    } else {\n      this.renderer.removeClass(elRef.nativeElement, this.classNameForInvalidControl)\n    }\n  }\n\n  private markValidityForAll (controls: AbstractControl[], addClass: boolean): void {\n    controls.forEach(control => this.markValidityFor(control, addClass))\n  }\n\n  private markAllAsValid () {\n    this.formControlElRefs.forEach(elRef => {\n      this.renderer.removeClass(elRef.nativeElement, this.classNameForInvalidControl)\n    })\n  }\n\n  public ngAfterContentInit (): void {\n    if (this.sinDirectives == null) {\n      // This form does not have any sins\n      return\n    }\n\n    this.formControls = rx.zip(\n      this.formControlNames.changes.pipe(rxop.startWith(this.formControlNames)),\n      this.formControlElRefs.changes.pipe(rxop.startWith(this.formControlElRefs)),\n    ).pipe(\n      rxop.map(([name, elRef]) => ({name, elRef})),\n    )\n\n    const visibleSins$: rx.Observable<AbstractControl[]> = this.sinDirectives.changes.pipe(\n      rxop.startWith(this.sinDirectives),\n      rxop.map((list: QueryList<SinDirective>) => list.toArray()),\n      rxop.switchMap((sins: SinDirective[]) =>\n        rx.combineLatest(sins.map(sin => sin.visible$))),\n      rxop.map((controls: AbstractControl[]) => controls.filter(control => control != null)),\n    )\n\n    this.formControls.pipe(\n      rxop.withLatestFrom(this.sinDirectives.changes.pipe(rxop.startWith(this.sinDirectives)), (fc, s) => s),\n      rxop.map((list: QueryList<SinDirective>) => list.toArray().map(sin => sin.visible$.getValue())),\n      rxop.map((controls: AbstractControl[]) => controls.filter(control => control != null)),\n      rxop.withLatestFrom(visibleSins$, (_, sins) => sins),\n    )\n      .subscribe((controls: AbstractControl[]) => {\n        // When form controls on the page change, we grab the last info about\n        // visible sins and use that. We have to be destructive here\n        this.markAllAsValid()\n        this.markValidityForAll(controls, true)\n      })\n\n    visibleSins$.pipe(rxop.pairwise())\n      .subscribe(([oldControls, newControls]: Pair<AbstractControl[]>) => {\n        // We can calculate diff instead of removing and setting everything.\n        const added = findAdded([oldControls, newControls])\n        const removed = findRemoved([oldControls, newControls])\n        this.markValidityForAll(added, true)\n        this.markValidityForAll(removed, false)\n      })\n  }\n\n  public ngOnDestroy () {\n    this.destroy$.next()\n  }\n\n}\n","import {SinModuleConfig, WhenObject} from './interfaces'\nimport {ModuleWithProviders, NgModule} from '@angular/core'\nimport {CommonModule} from '@angular/common'\nimport {ReactiveFormsModule} from '@angular/forms'\nimport {SinDirective} from './sin.directive'\nimport {SinsDirective} from './sins.directive'\nimport {FormWithSinsDirective} from './form-with-sins.directive'\nimport {SIN_CONFIG, SIN_FULL_CONFIG} from './config'\n\nexport function when ({dirty, touched}: Partial<WhenObject>): boolean {\n  return dirty && touched\n}\n\nexport const defaultConfig = {\n  when,\n}\n\nexport function factory (config?: Partial<SinModuleConfig>): SinModuleConfig {\n  return Object.assign({}, defaultConfig, config || {})\n}\n\nexport const DIRECTIVES = [\n  SinDirective,\n  SinsDirective,\n  FormWithSinsDirective,\n]\n\n@NgModule({\n  imports: [\n    CommonModule,\n    ReactiveFormsModule,\n  ],\n  declarations: DIRECTIVES,\n  exports: DIRECTIVES,\n})\nexport class SinModule {\n  public static forRoot (config?: Partial<SinModuleConfig>): ModuleWithProviders<SinModule> {\n    return {\n      ngModule: SinModule,\n      providers: [\n        {\n          provide: SIN_CONFIG,\n          useValue: config,\n        },\n        {\n          provide: SIN_FULL_CONFIG,\n          useFactory: factory,\n          deps: [SIN_CONFIG],\n        },\n      ],\n    }\n  }\n}\n"]}